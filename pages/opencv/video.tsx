import Head from "next/head";
import React, { useEffect, useRef, useCallback  } from "react";
import Navbar from "../../components/Navbar";
import styles from "../../styles/Home.module.css";

import { BBox } from "../../types";

const FPS = 30;

export default function Home() {
  const workerRef = useRef<Worker>()
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const videoRef = useRef<HTMLVideoElement>(null);
  const bboxsRef = useRef<BBox[]>();  // TODO: add type
  
  function handleLoadedMetadata() {
    const canvas = canvasRef.current;
    const video = videoRef.current;
    if (!canvas || !video) {
      return;
    }
    video.height = video.videoHeight;
    video.width = video.videoWidth;
    canvas.height = video.videoHeight;
    canvas.width = video.videoWidth;
    setTimeout(processVideo, 0);
  }

  async function processVideo() {
    let begin = Date.now();

    const video = videoRef.current;
    const bboxs = bboxsRef.current;
    const canvas = canvasRef.current;
    if (!video || !canvas) {
      return;
    }
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      return;
    }
    ctx.drawImage(video, 0, 0, video.width, video.height);
    if (bboxs) {
      for (let bbox of bboxs) {
        ctx.beginPath();
        ctx.rect(bbox.x1, bbox.y1, bbox.width, bbox.height);
        ctx.strokeStyle = "red";
        ctx.stroke();
      }
    }
    
    let delay = 1000 / FPS - (Date.now() - begin);
    setTimeout(processVideo, delay);
  }

  function startVideo() {
    const video = videoRef.current;
    const canvas = canvasRef.current;
    if (!video || !canvas) {
      return;
    }

    navigator.mediaDevices.getUserMedia({ video: true, audio: false })
      .then(function(stream) {
          video.srcObject = stream;
          video.play();
      })
      .catch(function(err) {
          console.log("An error occurred! " + err);
      });
  }

  const handleWork = useCallback(async () => {
    const canvas = canvasRef.current;
    const worker = workerRef.current;
    const video = videoRef.current;
    if (!canvas || !worker || !video) {
      return;
    }
    const ctx = canvas.getContext("2d");
    if (!ctx) {
      return;
    }
    
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    
    worker.postMessage({ msg: 'detect', imageData });
  }, [])

  useEffect(() => {
    workerRef.current = new Worker(new URL('../../workers/detection.worker.ts', import.meta.url))
    workerRef.current.onmessage = (event) => {
      switch (event.data.msg) {
        case 'detect':
          bboxsRef.current = event.data.bboxs;
          handleWork();
          break;
        case 'info':
          console.log(event.data.info);
          break;
        case 'error':
          console.error(event.data.error);
        default:
          console.log('Unknown message received from worker: ', event.data.msg);
      }
    }

    return () => {
      const worker = workerRef.current;
      if (!worker) {
        return;
      }
      worker.terminate()
    }
  }, [handleWork])

  return (
    <div className={styles.container}>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className={styles.main}>
        <Navbar />
        <h1>Test</h1>
        <div>
          <button onClick={startVideo}>Start Video</button>
          <button onClick={handleWork}>Ping Worker</button>
        </div>
        <div style={{ display: "flex" }}>
          <video ref={videoRef} width={680} height={680} onLoadedMetadata={handleLoadedMetadata}></video>
          <canvas
            width={640}
            height={640}
            ref={canvasRef}
            id="canvasOutput"
          ></canvas>
        </div>
      </main>
    </div>
  );
}
